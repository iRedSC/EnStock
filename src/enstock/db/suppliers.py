# Code generated by sqlc. DO NOT EDIT.
# versions:
#   sqlc v1.30.0
# source: suppliers.sql
import dataclasses
from typing import Any, AsyncIterator, Iterator, Optional

import sqlalchemy
import sqlalchemy.ext.asyncio

from enstock.db import models


GET_BRAND_BY_ABBV = """-- name: get_brand_by_abbv \\:one
SELECT id, name, abbv FROM brands WHERE abbv = ?
"""


GET_SUPPLIERS_WITH_BRAND = """-- name: get_suppliers_with_brand \\:many
SELECT
    suppliers.id,
    suppliers.name AS supplier_name,
    brands.id AS brand_id,
    brands.name AS brand_name,
    brands.abbv AS brand_abbv
FROM suppliers
LEFT JOIN brands ON suppliers.brand = brands.id
"""


@dataclasses.dataclass()
class GetSuppliersWithBrandRow:
    id: Any
    supplier_name: Any
    brand_id: Optional[Any]
    brand_name: Optional[Any]
    brand_abbv: Optional[Any]


INSERT_BRAND = """-- name: insert_brand \\:one
INSERT INTO brands (name, abbv)
VALUES (?, ?)
RETURNING id
"""


INSERT_SUPPLIER_NO_BRAND = """-- name: insert_supplier_no_brand \\:one
INSERT INTO suppliers (name, brand)
VALUES (?, NULL)
RETURNING id
"""


INSERT_SUPPLIER_WITH_BRAND = """-- name: insert_supplier_with_brand \\:one
INSERT INTO suppliers (name, brand)
VALUES (?, ?)
RETURNING id
"""


class Querier:
    def __init__(self, conn: sqlalchemy.engine.Connection):
        self._conn = conn

    def get_brand_by_abbv(self, *, abbv: Any) -> Optional[models.Brand]:
        row = self._conn.execute(sqlalchemy.text(GET_BRAND_BY_ABBV), {"p1": abbv}).first()
        if row is None:
            return None
        return models.Brand(
            id=row[0],
            name=row[1],
            abbv=row[2],
        )

    def get_suppliers_with_brand(self) -> Iterator[GetSuppliersWithBrandRow]:
        result = self._conn.execute(sqlalchemy.text(GET_SUPPLIERS_WITH_BRAND))
        for row in result:
            yield GetSuppliersWithBrandRow(
                id=row[0],
                supplier_name=row[1],
                brand_id=row[2],
                brand_name=row[3],
                brand_abbv=row[4],
            )

    def insert_brand(self, *, name: Any, abbv: Any) -> Optional[Any]:
        row = self._conn.execute(sqlalchemy.text(INSERT_BRAND), {"p1": name, "p2": abbv}).first()
        if row is None:
            return None
        return row[0]

    def insert_supplier_no_brand(self, *, name: Any) -> Optional[Any]:
        row = self._conn.execute(sqlalchemy.text(INSERT_SUPPLIER_NO_BRAND), {"p1": name}).first()
        if row is None:
            return None
        return row[0]

    def insert_supplier_with_brand(self, *, name: Any, brand: Optional[Any]) -> Optional[Any]:
        row = self._conn.execute(sqlalchemy.text(INSERT_SUPPLIER_WITH_BRAND), {"p1": name, "p2": brand}).first()
        if row is None:
            return None
        return row[0]


class AsyncQuerier:
    def __init__(self, conn: sqlalchemy.ext.asyncio.AsyncConnection):
        self._conn = conn

    async def get_brand_by_abbv(self, *, abbv: Any) -> Optional[models.Brand]:
        row = (await self._conn.execute(sqlalchemy.text(GET_BRAND_BY_ABBV), {"p1": abbv})).first()
        if row is None:
            return None
        return models.Brand(
            id=row[0],
            name=row[1],
            abbv=row[2],
        )

    async def get_suppliers_with_brand(self) -> AsyncIterator[GetSuppliersWithBrandRow]:
        result = await self._conn.stream(sqlalchemy.text(GET_SUPPLIERS_WITH_BRAND))
        async for row in result:
            yield GetSuppliersWithBrandRow(
                id=row[0],
                supplier_name=row[1],
                brand_id=row[2],
                brand_name=row[3],
                brand_abbv=row[4],
            )

    async def insert_brand(self, *, name: Any, abbv: Any) -> Optional[Any]:
        row = (await self._conn.execute(sqlalchemy.text(INSERT_BRAND), {"p1": name, "p2": abbv})).first()
        if row is None:
            return None
        return row[0]

    async def insert_supplier_no_brand(self, *, name: Any) -> Optional[Any]:
        row = (await self._conn.execute(sqlalchemy.text(INSERT_SUPPLIER_NO_BRAND), {"p1": name})).first()
        if row is None:
            return None
        return row[0]

    async def insert_supplier_with_brand(self, *, name: Any, brand: Optional[Any]) -> Optional[Any]:
        row = (await self._conn.execute(sqlalchemy.text(INSERT_SUPPLIER_WITH_BRAND), {"p1": name, "p2": brand})).first()
        if row is None:
            return None
        return row[0]
